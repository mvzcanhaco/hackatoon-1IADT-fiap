import gradio as gr
import os
from typing import Tuple, Any, Dict
from pathlib import Path
from src.application.use_cases.process_video import ProcessVideoUseCase, ProcessVideoRequest
from src.infrastructure.services.weapon_detector import WeaponDetectorService
from src.infrastructure.services.notification_services import NotificationServiceFactory
import logging
from huggingface_hub import hf_hub_download, HfApi
import tempfile

logger = logging.getLogger(__name__)

class GradioInterface:
    """Interface Gradio usando Clean Architecture."""
    
    def __init__(self):
        self.detector = WeaponDetectorService()
        self.notification_factory = NotificationServiceFactory()
        self.default_fps = 2 if self.detector.device_type == "GPU" else 1
        self.default_resolution = "640" if self.detector.device_type == "GPU" else "480"
        self.is_huggingface = os.getenv('SPACE_ID') is not None
        
        if self.is_huggingface:
            self._setup_huggingface_environment()
        
        self.use_case = ProcessVideoUseCase(
            detector=self.detector,
            notification_factory=self.notification_factory,
            default_fps=self.default_fps,
            default_resolution=int(self.default_resolution)
        )
    
    def _setup_huggingface_environment(self):
        """Configura o ambiente Hugging Face."""
        self.dataset_id = "marcuscanhaco/weapon-test"
        self.cache_dir = os.path.join(tempfile.gettempdir(), 'weapon_detection_videos')
        os.makedirs(self.cache_dir, exist_ok=True)
        
        self.hf_token = os.getenv('HF_TOKEN')
        self.api = HfApi(token=self.hf_token)
        
        try:
            files = self.api.list_repo_files(self.dataset_id, repo_type="dataset")
            self.sample_videos = [
                {
                    'path': f,
                    'name': Path(f).stem.replace('_', ' ').title(),
                    'ground_truth': 'üö® V√≠deo de Teste'
                }
                for f in files if f.lower().endswith(('.mp4', '.avi', '.mov', '.mkv'))
            ]
            logger.info(f"Encontrados {len(self.sample_videos)} v√≠deos no dataset")
        except Exception as e:
            logger.error(f"Erro ao listar arquivos do dataset: {str(e)}")
            self.sample_videos = []
    
    def _download_video(self, video_path: str) -> str:
        """Baixa um v√≠deo do dataset e retorna o caminho local."""
        try:
            local_path = hf_hub_download(
                repo_id=self.dataset_id,
                filename=video_path,
                repo_type="dataset",
                local_dir=self.cache_dir,
                token=self.hf_token,
                local_dir_use_symlinks=False
            )
            logger.info(f"V√≠deo baixado com sucesso: {local_path}")
            return local_path
        except Exception as e:
            logger.error(f"Erro ao baixar v√≠deo {video_path}: {str(e)}")
            return ""
    
    def list_sample_videos(self) -> list:
        """Lista os v√≠deos de exemplo do dataset ou da pasta local."""
        try:
            if self.is_huggingface:
                return self._list_huggingface_videos()
            else:
                return self._list_local_videos()
            
        except Exception as e:
            logger.error(f"Erro ao listar v√≠deos: {str(e)}")
            return []
    
    def _list_huggingface_videos(self) -> list:
        """Lista v√≠deos do ambiente Hugging Face."""
        logger.info("Ambiente Hugging Face detectado")
        videos = []
        for video in self.sample_videos:
            local_path = self._download_video(video['path'])
            if local_path:
                videos.append({
                    'path': local_path,
                    'name': video['name'],
                    'ground_truth': video['ground_truth']
                })
        return videos
    
    def _list_local_videos(self) -> list:
        """Lista v√≠deos do ambiente local."""
        logger.info("Ambiente local detectado, usando pasta videos")
        video_extensions = ['.mp4', '.avi', '.mov', '.mkv']
        videos = []
        base_dir = Path("videos")
        if not base_dir.exists():
            os.makedirs(base_dir)
            logger.info(f"Diret√≥rio videos criado: {base_dir}")
        
        for ext in video_extensions:
            for video_path in base_dir.glob(f'*{ext}'):
                videos.append({
                    'path': str(video_path),
                    'name': video_path.name,
                    'ground_truth': 'üìº V√≠deo de Teste'
                })
        
        return videos

    def load_sample_video(self, video_path: str) -> str:
        """Carrega um v√≠deo de exemplo."""
        try:
            if not video_path:
                return ""
            
            if os.path.exists(video_path):
                logger.info(f"Carregando v√≠deo: {video_path}")
                return video_path
                
            logger.warning(f"V√≠deo n√£o encontrado: {video_path}")
            return ""
        except Exception as e:
            logger.error(f"Erro ao carregar v√≠deo: {str(e)}")
            return ""
    
    def create_interface(self) -> gr.Blocks:
        """Cria a interface Gradio."""
        title = "FIAP VisionGuard - Risk Detection - Hackatoon 1IADT"
        sample_videos = self.list_sample_videos()
        
        with gr.Blocks(
            title=title,
            theme=gr.themes.Ocean(),
            css="footer {display: none !important}"
        ) as demo:
            self._create_header(title)
            self._create_processing_config()
            self._create_notification_config()
            self._create_video_interface()
            self._create_sample_videos(sample_videos)
        
        return demo
    
    def _create_header(self, title: str):
        """Cria o cabe√ßalho da interface."""
        gr.Markdown(f"""# üéØ {title} üî™üî´
        
        Fa√ßa upload de um v√≠deo para detectar objetos perigosos.
        Opcionalmente, configure notifica√ß√µes para receber alertas em caso de detec√ß√µes.

        **Importante para melhor performance:**
        - V√≠deos de at√© 60 segundos
        - FPS entre 1-2 para an√°lise com maior performance
        - FPS maior que 2 para an√°lise com maior precis√£o
        """)
    
    def _create_processing_config(self):
        """Cria a se√ß√£o de configura√ß√£o de processamento."""
        with gr.Group():
            gr.Markdown("""### Configura√ß√£o de Processamento""")
            with gr.Row():
                self.threshold = gr.Slider(
                    minimum=0.1,
                    maximum=1.0,
                    value=0.5,
                    step=0.1,
                    label="Limiar de Detec√ß√£o",
                )
                self.fps = gr.Slider(
                    minimum=1,
                    maximum=5,
                    value=self.default_fps,
                    step=1,
                    label="Frames por Segundo",
                )
                self.resolution = gr.Radio(
                    choices=["480", "640", "768"],
                    value=self.default_resolution,
                    label="Resolu√ß√£o de Processamento",
                )
    
    def _create_notification_config(self):
        """Cria a se√ß√£o de configura√ß√£o de notifica√ß√µes."""
        with gr.Group():
            gr.Markdown("""### Configura√ß√£o de Notifica√ß√µes de Detec√ß√£o (Opcional)""")
            with gr.Row():
                self.notification_type = gr.Radio(
                    choices=self.notification_factory.get_available_services(),
                    value="email",
                    label="Tipo de Notifica√ß√£o",
                    interactive=True,
                )
                self.notification_target = gr.Textbox(
                    label="Destino da Notifica√ß√£o (E-mail)",
                    placeholder="exemplo@email.com",
                )
    
    def _create_video_interface(self):
        """Cria a interface de v√≠deo."""
        with gr.Row():
            with gr.Column(scale=2):
                self.input_video = gr.Video(
                    label="V√≠deo de Entrada",
                    format="mp4",
                    interactive=True,
                    height=400
                )
                
                self.submit_btn = gr.Button(
                    "Detectar",
                    variant="primary",
                    scale=2
                )
            
            with gr.Column(scale=1):
                self.status = gr.Textbox(
                    label="Status da Detec√ß√£o",
                    lines=4,
                    show_copy_button=True
                )
                with gr.Accordion("Detalhes T√©cnicos", open=False):
                    self.json_output = gr.JSON(
                        label="Detalhes T√©cnicos",
                    )
                
                with gr.Accordion("Informa√ß√µes Adicionais", open=False):
                    gr.Markdown("""
                    ### Sobre o Detector
                    Este sistema utiliza um modelo de IA avan√ßado para detectar objetos perigosos em v√≠deos.
                    
                    ### Tipos de Objetos Detectados
                    - Armas de fogo (pistolas, rifles, etc.)
                    - Armas brancas (facas, canivetes, etc.)
                    - Objetos perigosos (bast√µes, objetos pontiagudos, etc.)
                    
                    ### Recomenda√ß√µes
                    - Use v√≠deos com boa ilumina√ß√£o
                    - Evite v√≠deos muito longos
                    - Mantenha os objetos vis√≠veis e em foco
                    """)
        
        self.submit_btn.click(
            fn=lambda *args: self._process_video(*args),
            inputs=[
                self.input_video,
                self.threshold,
                self.fps,
                self.resolution,
                self.notification_type,
                self.notification_target
            ],
            outputs=[self.status, self.json_output]
        )
    
    def _create_sample_videos(self, sample_videos: list):
        """Cria a se√ß√£o de v√≠deos de exemplo."""
        if sample_videos:
            gr.Markdown("### V√≠deos de Exemplo")
            examples = [
                [video['path']] for video in sample_videos
            ]
            gr.Examples(
                examples=examples,
                inputs=self.input_video,
                outputs=self.input_video,
                fn=self.load_sample_video,
                label="Clique em um v√≠deo para carreg√°-lo"
            )
    
    def _process_video(
        self,
        video_path: str,
        threshold: float = 0.5,
        fps: int = None,
        resolution: str = None,
        notification_type: str = None,
        notification_target: str = None
    ) -> Tuple[str, Dict[str, Any]]:
        """Processa o v√≠deo usando o caso de uso."""
        try:
            if not video_path:
                return "Erro: Nenhum v√≠deo fornecido", {}
                
            fps = fps or self.default_fps
            resolution = resolution or self.default_resolution
            
            request = ProcessVideoRequest(
                video_path=video_path,
                threshold=threshold,
                fps=fps,
                resolution=int(resolution),
                notification_type=notification_type,
                notification_target=notification_target
            )
            
            response = self.use_case.execute(request)
            status_msg = self._format_status_message(response.detection_result)
            technical_data = self._format_technical_data(response, fps, resolution)
            
            return status_msg, technical_data
            
        except Exception as e:
            logger.error(f"Erro ao processar v√≠deo: {str(e)}")
            return "Erro ao processar o v√≠deo. Por favor, tente novamente.", {
                "error": str(e),
                "device_type": "unknown",
                "total_detections": 0,
                "frames_analyzed": 0
            }
    
    def _format_technical_data(
        self,
        response: Any,
        fps: int,
        resolution: str
    ) -> Dict[str, Any]:
        """Formata os dados t√©cnicos do processamento."""
        technical_data = {
            "device_info": {
                "type": response.detection_result.device_type,
                "memory": response.memory_info,
                "details": response.device_info
            },
            "processing_stats": {
                "total_detections": len(response.detection_result.detections),
                "frames_analyzed": response.detection_result.frames_analyzed,
                "total_time": round(response.detection_result.total_time, 2),
                "frame_extraction_time": round(response.detection_result.frame_extraction_time, 2),
                "analysis_time": round(response.detection_result.analysis_time, 2),
                "fps": fps,
                "resolution": resolution
            },
            "detections": [],
            "cache_stats": response.cache_stats if hasattr(response, 'cache_stats') else {}
        }
        
        for det in response.detection_result.detections[:10]:
            technical_data["detections"].append({
                "label": det.label,
                "confidence": round(det.confidence * 100 if det.confidence <= 1.0 else det.confidence, 2),
                "frame": det.frame,
                "timestamp": f"{int(det.timestamp // 60):02d}:{int(det.timestamp % 60):02d}",
                "box": det.box if hasattr(det, "box") else None
            })
        
        return technical_data
            
    def _format_status_message(self, result) -> str:
        """Formata a mensagem de status do processamento."""
        try:
            status = "‚ö†Ô∏è RISCO DETECTADO" if result.detections else "‚úÖ SEGURO"
            
            message = f"""Status: {status}
Processado em: {result.device_type}
Total de detec√ß√µes: {len(result.detections)}
Frames analisados: {result.frames_analyzed}
Tempo total: {result.total_time:.2f}s"""

            if result.detections:
                message += "\n\nDetec√ß√µes encontradas:"
                for i, det in enumerate(result.detections[:5], 1):
                    confidence_pct = det.confidence * 100 if det.confidence <= 1.0 else det.confidence
                    message += f"\n{i}. {det.label} (Confian√ßa: {confidence_pct:.1f}%, Frame: {det.frame})"
                if len(result.detections) > 5:
                    message += f"\n... e mais {len(result.detections) - 5} detec√ß√£o(√µes)"
            
            return message
            
        except Exception as e:
            logger.error(f"Erro ao formatar mensagem de status: {str(e)}")
            return "Erro ao processar o v√≠deo. Por favor, tente novamente." 